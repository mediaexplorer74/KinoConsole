// Decompiled with JetBrains decompiler
// Type: BrightIdeasSoftware.OLVColumn
// Assembly: rdconfig, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: D72BB1D7-1CC3-4208-97DD-547FCD4348CA
// Assembly location: C:\Users\Admin\Desktop\RE\Kinoni\rdconfig.exe

using System;
using System.Collections;
using System.ComponentModel;
using System.Drawing;
using System.Drawing.Design;
using System.Windows.Forms;


namespace BrightIdeasSoftware
{
  [Browsable(false)]
  public class OLVColumn : ColumnHeader
  {
    private AspectGetterDelegate aspectGetter;
    private bool aspectGetterAutoGenerated;
    private string aspectName;
    private AspectPutterDelegate aspectPutter;
    private AspectToStringConverterDelegate aspectToStringConverter;
    private string aspectToStringFormat;
    private AutoCompleteMode autoCompleteEditorMode = AutoCompleteMode.Append;
    private Rectangle? cellPadding;
    private StringAlignment? cellVerticalAlignment;
    private bool checkBoxes;
    private IClusteringStrategy clusteringStrategy;
    private int freeSpaceProportion;
    private bool groupable = true;
    private GroupFormatterDelegate groupFormatter;
    private GroupKeyGetterDelegate groupKeyGetter;
    private GroupKeyToTitleConverterDelegate groupKeyToTitleConverter;
    private string groupWithItemCountFormat;
    private string cachedGroupWithItemCountFormat;
    private string groupWithItemCountSingularFormat;
    private string cachedGroupWithItemCountSingularFormat;
    private HeaderDrawingDelegate headerDrawing;
    private HeaderFormatStyle headerFormatStyle;
    private string headerImageKey;
    private HorizontalAlignment? headerTextAlign;
    private bool hideable = true;
    private bool hyperlink;
    private string imageAspectName;
    private ImageGetterDelegate imageGetter;
    private bool isEditable = true;
    private bool isTileViewColumn;
    private bool isHeaderVertical;
    private bool isVisible = true;
    private int lastDisplayIndex = -1;
    private int maxWidth = -1;
    private int minWidth = -1;
    private IRenderer renderer;
    private bool searchable = true;
    private bool showTextInHeader = true;
    private bool sortable = true;
    private HorizontalAlignment? textAlign;
    private string toolTipText;
    private bool triStateCheckBoxes;
    private bool useInitialLetterForGroup;
    private bool useFiltering = true;
    private IModelFilter valueBasedFilter;
    private IList valuesChosenForFiltering = (IList) new ArrayList();
    private bool wordWrap;
    private Munger aspectMunger;
    private Munger imageAspectMunger;
    private System.Type dataType;

    public OLVColumn()
    {
    }

    public OLVColumn(string title, string aspect)
      : this()
    {
      this.Text = title;
      this.AspectName = aspect;
    }

    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    [Browsable(false)]
    public AspectGetterDelegate AspectGetter
    {
      get => this.aspectGetter;
      set => this.aspectGetter = value;
    }

    [Browsable(false)]
    [Obsolete("This property is no longer maintained", true)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public bool AspectGetterAutoGenerated
    {
      get => this.aspectGetterAutoGenerated;
      set => this.aspectGetterAutoGenerated = value;
    }

    [Category("ObjectListView")]
    [DefaultValue(null)]
    [Description("The name of the property or method that should be called to get the aspect to display in this column")]
    public string AspectName
    {
      get => this.aspectName;
      set
      {
        this.aspectName = value;
        this.aspectMunger = (Munger) null;
      }
    }

    [Browsable(false)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public AspectPutterDelegate AspectPutter
    {
      get => this.aspectPutter;
      set => this.aspectPutter = value;
    }

    [Browsable(false)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public AspectToStringConverterDelegate AspectToStringConverter
    {
      get => this.aspectToStringConverter;
      set => this.aspectToStringConverter = value;
    }

    [Description("The format string that will be used to convert an aspect to its string representation")]
    [DefaultValue(null)]
    [Category("ObjectListView")]
    public string AspectToStringFormat
    {
      get => this.aspectToStringFormat;
      set => this.aspectToStringFormat = value;
    }

    [Description("Should the editor for cells of this column use AutoComplete")]
    [DefaultValue(true)]
    [Category("ObjectListView")]
    public bool AutoCompleteEditor
    {
      get => this.AutoCompleteEditorMode != AutoCompleteMode.None;
      set
      {
        if (value)
        {
          if (this.AutoCompleteEditorMode != AutoCompleteMode.None)
            return;
          this.AutoCompleteEditorMode = AutoCompleteMode.Append;
        }
        else
          this.AutoCompleteEditorMode = AutoCompleteMode.None;
      }
    }

    [DefaultValue(AutoCompleteMode.Append)]
    [Category("ObjectListView")]
    [Description("Should the editor for cells of this column use AutoComplete")]
    public AutoCompleteMode AutoCompleteEditorMode
    {
      get => this.autoCompleteEditorMode;
      set => this.autoCompleteEditorMode = value;
    }

    [Browsable(false)]
    public bool CanBeHidden => this.Hideable && this.Index != 0;

    public Rectangle? CellPadding
    {
      get => this.cellPadding;
      set => this.cellPadding = value;
    }

    [Description("How will cell values be vertically aligned?")]
    [DefaultValue(null)]
    [Category("ObjectListView")]
    public virtual StringAlignment? CellVerticalAlignment
    {
      get => this.cellVerticalAlignment;
      set => this.cellVerticalAlignment = value;
    }

    [DefaultValue(false)]
    [Description("Should values in this column be treated as a checkbox, rather than a string?")]
    [Category("ObjectListView")]
    public virtual bool CheckBoxes
    {
      get => this.checkBoxes;
      set
      {
        if (this.checkBoxes == value)
          return;
        this.checkBoxes = value;
        if (this.checkBoxes)
        {
          if (this.Renderer != null)
            return;
          this.Renderer = (IRenderer) new CheckStateRenderer();
        }
        else
        {
          if (!(this.Renderer is CheckStateRenderer))
            return;
          this.Renderer = (IRenderer) null;
        }
      }
    }

    [Browsable(false)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public IClusteringStrategy ClusteringStrategy
    {
      get
      {
        if (this.clusteringStrategy == null)
          this.ClusteringStrategy = this.DecideDefaultClusteringStrategy();
        return this.clusteringStrategy;
      }
      set
      {
        this.clusteringStrategy = value;
        if (this.clusteringStrategy == null)
          return;
        this.clusteringStrategy.Column = this;
      }
    }

    [Category("ObjectListView")]
    [Description("Will this column resize to fill unoccupied horizontal space in the listview?")]
    [DefaultValue(false)]
    public bool FillsFreeSpace
    {
      get => this.FreeSpaceProportion > 0;
      set => this.freeSpaceProportion = value ? 1 : 0;
    }

    [Browsable(false)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public int FreeSpaceProportion
    {
      get => this.freeSpaceProportion;
      set => this.freeSpaceProportion = Math.Max(0, value);
    }

    [Description("Will the list create groups when this header is clicked?")]
    [Category("ObjectListView")]
    [DefaultValue(true)]
    public bool Groupable
    {
      get => this.groupable;
      set => this.groupable = value;
    }

    [Browsable(false)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public GroupFormatterDelegate GroupFormatter
    {
      get => this.groupFormatter;
      set => this.groupFormatter = value;
    }

    [Browsable(false)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public GroupKeyGetterDelegate GroupKeyGetter
    {
      get => this.groupKeyGetter;
      set => this.groupKeyGetter = value;
    }

    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    [Browsable(false)]
    public GroupKeyToTitleConverterDelegate GroupKeyToTitleConverter
    {
      get => this.groupKeyToTitleConverter;
      set => this.groupKeyToTitleConverter = value;
    }

    [Description("The format to use when suffixing item counts to group titles")]
    [DefaultValue(null)]
    [Category("ObjectListView")]
    [Localizable(true)]
    public string GroupWithItemCountFormat
    {
      get => this.groupWithItemCountFormat;
      set => this.groupWithItemCountFormat = value;
    }

    [Browsable(false)]
    public string GroupWithItemCountFormatOrDefault
    {
      get
      {
        if (!string.IsNullOrEmpty(this.GroupWithItemCountFormat))
          return this.GroupWithItemCountFormat;
        if (this.ListView == null)
          return this.cachedGroupWithItemCountFormat ?? "{0} [{1} items]";
        this.cachedGroupWithItemCountFormat = ((ObjectListView) this.ListView).GroupWithItemCountFormatOrDefault;
        return this.cachedGroupWithItemCountFormat;
      }
    }

    [DefaultValue(null)]
    [Category("ObjectListView")]
    [Description("The format to use when suffixing item counts to group titles")]
    [Localizable(true)]
    public string GroupWithItemCountSingularFormat
    {
      get => this.groupWithItemCountSingularFormat;
      set => this.groupWithItemCountSingularFormat = value;
    }

    [Browsable(false)]
    public string GroupWithItemCountSingularFormatOrDefault
    {
      get
      {
        if (!string.IsNullOrEmpty(this.GroupWithItemCountSingularFormat))
          return this.GroupWithItemCountSingularFormat;
        if (this.ListView == null)
          return this.cachedGroupWithItemCountSingularFormat ?? "{0} [{1} item]";
        this.cachedGroupWithItemCountSingularFormat = ((ObjectListView) this.ListView).GroupWithItemCountSingularFormatOrDefault;
        return this.cachedGroupWithItemCountSingularFormat;
      }
    }

    [Browsable(false)]
    public bool HasFilterIndicator
    {
      get
      {
        return this.UseFiltering && this.ValuesChosenForFiltering != null && this.ValuesChosenForFiltering.Count > 0;
      }
    }

    [Browsable(false)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public HeaderDrawingDelegate HeaderDrawing
    {
      get => this.headerDrawing;
      set => this.headerDrawing = value;
    }

    [Description("What style will be used to draw the header of this column")]
    [Category("ObjectListView")]
    [DefaultValue(null)]
    public HeaderFormatStyle HeaderFormatStyle
    {
      get => this.headerFormatStyle;
      set => this.headerFormatStyle = value;
    }

    [Browsable(false)]
    [DefaultValue(null)]
    public Font HeaderFont
    {
      get => this.HeaderFormatStyle != null ? this.HeaderFormatStyle.Normal.Font : (Font) null;
      set
      {
        if (value == null && this.HeaderFormatStyle == null)
          return;
        if (this.HeaderFormatStyle == null)
          this.HeaderFormatStyle = new HeaderFormatStyle();
        this.HeaderFormatStyle.SetFont(value);
      }
    }

    [DefaultValue(typeof (Color), "")]
    [Browsable(false)]
    public Color HeaderForeColor
    {
      get => this.HeaderFormatStyle != null ? this.HeaderFormatStyle.Normal.ForeColor : Color.Empty;
      set
      {
        if (value.IsEmpty && this.HeaderFormatStyle == null)
          return;
        if (this.HeaderFormatStyle == null)
          this.HeaderFormatStyle = new HeaderFormatStyle();
        this.HeaderFormatStyle.SetForeColor(value);
      }
    }

    [Editor("System.Windows.Forms.Design.ImageIndexEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof (UITypeEditor))]
    [DefaultValue(null)]
    [RefreshProperties(RefreshProperties.Repaint)]
    [TypeConverter(typeof (ImageKeyConverter))]
    [Category("ObjectListView")]
    [Description("Name of the image that will be shown in the column header.")]
    public string HeaderImageKey
    {
      get => this.headerImageKey;
      set => this.headerImageKey = value;
    }

    [DefaultValue(HorizontalAlignment.Left)]
    [Description("How will the header text be aligned?")]
    [Category("ObjectListView")]
    public HorizontalAlignment HeaderTextAlign
    {
      get => !this.headerTextAlign.HasValue ? this.TextAlign : this.headerTextAlign.Value;
      set => this.headerTextAlign = new HorizontalAlignment?(value);
    }

    [Browsable(false)]
    public StringAlignment HeaderTextAlignAsStringAlignment
    {
      get
      {
        switch (this.HeaderTextAlign)
        {
          case HorizontalAlignment.Left:
            return StringAlignment.Near;
          case HorizontalAlignment.Right:
            return StringAlignment.Far;
          case HorizontalAlignment.Center:
            return StringAlignment.Center;
          default:
            return StringAlignment.Near;
        }
      }
    }

    [Browsable(false)]
    public bool HasHeaderImage
    {
      get
      {
        return this.ListView != null && this.ListView.SmallImageList != null && this.ListView.SmallImageList.Images.ContainsKey(this.HeaderImageKey);
      }
    }

    [DefaultValue(true)]
    [Category("ObjectListView")]
    [Description("Will the user be able to choose to hide this column?")]
    public bool Hideable
    {
      get => this.hideable;
      set => this.hideable = value;
    }

    [DefaultValue(false)]
    [Category("ObjectListView")]
    [Description("Will the text values of this column act like hyperlinks?")]
    public bool Hyperlink
    {
      get => this.hyperlink;
      set => this.hyperlink = value;
    }

    [Description("The name of the property that holds the image selector")]
    [Category("ObjectListView")]
    [DefaultValue(null)]
    public string ImageAspectName
    {
      get => this.imageAspectName;
      set => this.imageAspectName = value;
    }

    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    [Browsable(false)]
    public ImageGetterDelegate ImageGetter
    {
      get => this.imageGetter;
      set => this.imageGetter = value;
    }

    [DefaultValue(true)]
    [Description("Can the value in this column be edited?")]
    [Category("ObjectListView")]
    public bool IsEditable
    {
      get => this.isEditable;
      set => this.isEditable = value;
    }

    [Browsable(false)]
    public bool IsFixedWidth
    {
      get
      {
        return this.MinimumWidth != -1 && this.MaximumWidth != -1 && this.MinimumWidth >= this.MaximumWidth;
      }
    }

    [Category("ObjectListView")]
    [DefaultValue(false)]
    [Description("Will this column be used when the view is switched to tile view")]
    public bool IsTileViewColumn
    {
      get => this.isTileViewColumn;
      set => this.isTileViewColumn = value;
    }

    [Description("Will the header for this column be drawn vertically?")]
    [Category("ObjectListView")]
    [DefaultValue(false)]
    public bool IsHeaderVertical
    {
      get => this.isHeaderVertical;
      set => this.isHeaderVertical = value;
    }

    [Category("ObjectListView")]
    [Description("Can this column be seen by the user?")]
    [DefaultValue(true)]
    public bool IsVisible
    {
      get => this.isVisible;
      set => this.isVisible = value;
    }

    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    [Browsable(false)]
    public int LastDisplayIndex
    {
      get => this.lastDisplayIndex;
      set => this.lastDisplayIndex = value;
    }

    [DefaultValue(-1)]
    [Category("ObjectListView")]
    [Description("What is the maximum width to which the user can resize this column?")]
    public int MaximumWidth
    {
      get => this.maxWidth;
      set
      {
        this.maxWidth = value;
        if (this.maxWidth == -1 || this.Width <= this.maxWidth)
          return;
        this.Width = this.maxWidth;
      }
    }

    [Category("ObjectListView")]
    [Description("What is the minimum width to which the user can resize this column?")]
    [DefaultValue(-1)]
    public int MinimumWidth
    {
      get => this.minWidth;
      set
      {
        this.minWidth = value;
        if (this.Width >= this.minWidth)
          return;
        this.Width = this.minWidth;
      }
    }

    [Description("The renderer will draw this column when the ListView is owner drawn")]
    [Category("ObjectListView")]
    [DefaultValue(null)]
    public IRenderer Renderer
    {
      get => this.renderer;
      set => this.renderer = value;
    }

    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    [Browsable(false)]
    public RenderDelegate RendererDelegate
    {
      get
      {
        return this.Renderer is Version1Renderer ? ((Version1Renderer) this.Renderer).RenderDelegate : (RenderDelegate) null;
      }
      set
      {
        this.Renderer = value == null ? (IRenderer) null : (IRenderer) new Version1Renderer(value);
      }
    }

    [Description("Will the text of the cells in this column be considered when searching?")]
    [Category("ObjectListView")]
    [DefaultValue(true)]
    public bool Searchable
    {
      get => this.searchable;
      set => this.searchable = value;
    }

    [DefaultValue(true)]
    [Category("ObjectListView")]
    [Description("Will the header for this column include text?")]
    public bool ShowTextInHeader
    {
      get => this.showTextInHeader;
      set => this.showTextInHeader = value;
    }

    [Category("ObjectListView")]
    [Description("Will clicking this columns header resort the list?")]
    [DefaultValue(true)]
    public bool Sortable
    {
      get => this.sortable;
      set => this.sortable = value;
    }

    public new HorizontalAlignment TextAlign
    {
      get => !this.textAlign.HasValue ? base.TextAlign : this.textAlign.Value;
      set
      {
        this.textAlign = new HorizontalAlignment?(value);
        base.TextAlign = value;
      }
    }

    [Browsable(false)]
    public StringAlignment TextStringAlign
    {
      get
      {
        switch (this.TextAlign)
        {
          case HorizontalAlignment.Left:
            return StringAlignment.Near;
          case HorizontalAlignment.Right:
            return StringAlignment.Far;
          case HorizontalAlignment.Center:
            return StringAlignment.Center;
          default:
            return StringAlignment.Near;
        }
      }
    }

    [DefaultValue(null)]
    [Category("ObjectListView")]
    [Description("The tooltip to show when the mouse is hovered over the header of this column")]
    [Localizable(true)]
    public string ToolTipText
    {
      get => this.toolTipText;
      set => this.toolTipText = value;
    }

    [Category("ObjectListView")]
    [DefaultValue(false)]
    [Description("Should values in this column be treated as a tri-state checkbox?")]
    public virtual bool TriStateCheckBoxes
    {
      get => this.triStateCheckBoxes;
      set
      {
        this.triStateCheckBoxes = value;
        if (!value || this.CheckBoxes)
          return;
        this.CheckBoxes = true;
      }
    }

    [DefaultValue(false)]
    [Category("ObjectListView")]
    [Description("The name of the property or method that should be called to get the aspect to display in this column")]
    public bool UseInitialLetterForGroup
    {
      get => this.useInitialLetterForGroup;
      set => this.useInitialLetterForGroup = value;
    }

    [Category("ObjectListView")]
    [DefaultValue(true)]
    [Description("Does this column want to show a Filter menu item when its header is right clicked")]
    public bool UseFiltering
    {
      get => this.useFiltering;
      set => this.useFiltering = value;
    }

    [Browsable(false)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public IModelFilter ValueBasedFilter
    {
      get
      {
        if (!this.UseFiltering)
          return (IModelFilter) null;
        if (this.valueBasedFilter != null)
          return this.valueBasedFilter;
        if (this.ClusteringStrategy == null)
          return (IModelFilter) null;
        return this.ValuesChosenForFiltering == null || this.ValuesChosenForFiltering.Count == 0 ? (IModelFilter) null : this.ClusteringStrategy.CreateFilter(this.ValuesChosenForFiltering);
      }
      set => this.valueBasedFilter = value;
    }

    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    [Browsable(false)]
    public IList ValuesChosenForFiltering
    {
      get => this.valuesChosenForFiltering;
      set => this.valuesChosenForFiltering = value;
    }

    [Category("ObjectListView")]
    [DefaultValue(60)]
    [Description("The width in pixels of this column")]
    public new int Width
    {
      get => base.Width;
      set
      {
        if (this.MaximumWidth != -1 && value > this.MaximumWidth)
          base.Width = this.MaximumWidth;
        else
          base.Width = Math.Max(this.MinimumWidth, value);
      }
    }

    [Description("Draw this column cell's word wrapped")]
    [Category("ObjectListView")]
    [DefaultValue(false)]
    public bool WordWrap
    {
      get => this.wordWrap;
      set
      {
        this.wordWrap = value;
        if (this.Renderer == null && !this.wordWrap)
          return;
        if (this.Renderer == null)
          this.Renderer = (IRenderer) new HighlightTextRenderer();
        if (!(this.Renderer is BaseRenderer renderer))
          return;
        renderer.CanWrap = this.wordWrap;
      }
    }

    public string ConvertGroupKeyToTitle(object value)
    {
      if (this.groupKeyToTitleConverter != null)
        return this.groupKeyToTitleConverter(value);
      return value != null ? this.ValueToString(value) : "{null}";
    }

    public CheckState GetCheckState(object rowObject)
    {
      if (!this.CheckBoxes)
        return CheckState.Unchecked;
      bool? nullable = this.GetValue(rowObject) as bool?;
      if (!nullable.HasValue)
        return CheckState.Indeterminate;
      return nullable.Value ? CheckState.Checked : CheckState.Unchecked;
    }

    public void PutCheckState(object rowObject, CheckState newState)
    {
      if (newState == CheckState.Checked)
        this.PutValue(rowObject, (object) true);
      else if (newState == CheckState.Unchecked)
        this.PutValue(rowObject, (object) false);
      else
        this.PutValue(rowObject, (object) null);
    }

    public object GetAspectByName(object rowObject)
    {
      if (this.aspectMunger == null)
        this.aspectMunger = new Munger(this.AspectName);
      return this.aspectMunger.GetValue(rowObject);
    }

    public object GetGroupKey(object rowObject)
    {
      if (this.groupKeyGetter != null)
        return this.groupKeyGetter(rowObject);
      object upper = this.GetValue(rowObject);
      if (upper is string str && this.UseInitialLetterForGroup && str.Length > 0)
        upper = (object) str.Substring(0, 1).ToUpper();
      return upper;
    }

    public object GetImage(object rowObject)
    {
      if (this.CheckBoxes)
        return (object) this.GetCheckStateImage(rowObject);
      if (this.ImageGetter != null)
        return this.ImageGetter(rowObject);
      if (!string.IsNullOrEmpty(this.ImageAspectName))
      {
        if (this.imageAspectMunger == null)
          this.imageAspectMunger = new Munger(this.ImageAspectName);
        return this.imageAspectMunger.GetValue(rowObject);
      }
      return !string.IsNullOrEmpty(this.ImageKey) ? (object) this.ImageKey : (object) this.ImageIndex;
    }

    public string GetCheckStateImage(object rowObject)
    {
      switch (this.GetCheckState(rowObject))
      {
        case CheckState.Unchecked:
          return "checkbox-unchecked";
        case CheckState.Checked:
          return "checkbox-checked";
        default:
          return "checkbox-indeterminate";
      }
    }

    public string GetStringValue(object rowObject) => this.ValueToString(this.GetValue(rowObject));

    public object GetValue(object rowObject)
    {
      return this.AspectGetter == null ? this.GetAspectByName(rowObject) : this.AspectGetter(rowObject);
    }

    public void PutAspectByName(object rowObject, object newValue)
    {
      if (this.aspectMunger == null)
        this.aspectMunger = new Munger(this.AspectName);
      this.aspectMunger.PutValue(rowObject, newValue);
    }

    public void PutValue(object rowObject, object newValue)
    {
      if (this.aspectPutter == null)
        this.PutAspectByName(rowObject, newValue);
      else
        this.aspectPutter(rowObject, newValue);
    }

    public string ValueToString(object value)
    {
      if (this.AspectToStringConverter != null)
        return this.AspectToStringConverter(value) ?? string.Empty;
      if (value == null)
        return string.Empty;
      string aspectToStringFormat = this.AspectToStringFormat;
      return string.IsNullOrEmpty(aspectToStringFormat) ? value.ToString() : string.Format(aspectToStringFormat, value);
    }

    private IClusteringStrategy DecideDefaultClusteringStrategy()
    {
      if (!this.UseFiltering)
        return (IClusteringStrategy) null;
      return (object) this.DataType == (object) typeof (DateTime) ? (IClusteringStrategy) new DateTimeClusteringStrategy() : (IClusteringStrategy) new ClustersFromGroupsStrategy();
    }

    [Browsable(false)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public System.Type DataType
    {
      get
      {
        if ((object) this.dataType == null && this.ListView is ObjectListView listView)
        {
          object firstNonNullValue = listView.GetFirstNonNullValue(this);
          if (firstNonNullValue != null)
            return firstNonNullValue.GetType();
        }
        return this.dataType;
      }
      set => this.dataType = value;
    }

    public void MakeGroupies(object[] values, string[] descriptions)
    {
      this.MakeGroupies<object>(values, descriptions, (object[]) null, (string[]) null, (string[]) null);
    }

    public void MakeGroupies<T>(T[] values, string[] descriptions)
    {
      this.MakeGroupies<T>(values, descriptions, (object[]) null, (string[]) null, (string[]) null);
    }

    public void MakeGroupies<T>(T[] values, string[] descriptions, object[] images)
    {
      this.MakeGroupies<T>(values, descriptions, images, (string[]) null, (string[]) null);
    }

    public void MakeGroupies<T>(
      T[] values,
      string[] descriptions,
      object[] images,
      string[] subtitles)
    {
      this.MakeGroupies<T>(values, descriptions, images, subtitles, (string[]) null);
    }

    public void MakeGroupies<T>(
      T[] values,
      string[] descriptions,
      object[] images,
      string[] subtitles,
      string[] tasks)
    {
      if (values == null)
        throw new ArgumentNullException(nameof (values));
      if (descriptions == null)
        throw new ArgumentNullException(nameof (descriptions));
      if (values.Length + 1 != descriptions.Length)
        throw new ArgumentException("descriptions must have one more element than values.");
      this.GroupKeyGetter = (GroupKeyGetterDelegate) (row =>
      {
        object obj = this.GetValue(row);
        if (obj == null || obj == DBNull.Value)
          return (object) -1;
        IComparable comparable = (IComparable) obj;
        for (int index = 0; index < values.Length; ++index)
        {
          if (comparable.CompareTo((object) values[index]) < 0)
            return (object) index;
        }
        return (object) (descriptions.Length - 1);
      });
      this.GroupKeyToTitleConverter = (GroupKeyToTitleConverterDelegate) (key => (int) key < 0 ? "" : descriptions[(int) key]);
      this.GroupFormatter = (GroupFormatterDelegate) ((group, parms) =>
      {
        int key = (int) group.Key;
        if (key < 0)
          return;
        if (images != null && key < images.Length)
          group.TitleImage = images[key];
        if (subtitles != null && key < subtitles.Length)
          group.Subtitle = subtitles[key];
        if (tasks == null || key >= tasks.Length)
          return;
        group.Task = tasks[key];
      });
    }

    public void MakeEqualGroupies<T>(
      T[] values,
      string[] descriptions,
      object[] images,
      string[] subtitles,
      string[] tasks)
    {
      if (values == null)
        throw new ArgumentNullException(nameof (values));
      if (descriptions == null)
        throw new ArgumentNullException(nameof (descriptions));
      if (values.Length != descriptions.Length)
        throw new ArgumentException("descriptions must have the same number of elements as values.");
      ArrayList valuesArray = new ArrayList((ICollection) values);
      this.GroupKeyGetter = (GroupKeyGetterDelegate) (row => (object) valuesArray.IndexOf(this.GetValue(row)));
      this.GroupKeyToTitleConverter = (GroupKeyToTitleConverterDelegate) (key =>
      {
        int index = (int) key;
        return index >= 0 ? descriptions[index] : "[other]";
      });
      this.GroupFormatter = (GroupFormatterDelegate) ((group, parms) =>
      {
        int key = (int) group.Key;
        if (key < 0)
          return;
        if (images != null && key < images.Length)
          group.TitleImage = images[key];
        if (subtitles != null && key < subtitles.Length)
          group.Subtitle = subtitles[key];
        if (tasks == null || key >= tasks.Length)
          return;
        group.Task = tasks[key];
      });
    }
  }
}
